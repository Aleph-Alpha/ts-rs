#![allow(dead_code)]

use std::{concat, fs};

use ts_rs::TS;

/* ============================================================================================== */

/// Doc comment.
/// Supports new lines.
///
/// Testing
#[derive(TS)]
#[ts(export_to = "tests-out/docs/")]
struct A {
    /// Doc of field
    ///
    /// Testing
    name: String,
}

#[derive(TS)]
#[ts(export_to = "tests-out/docs/")]
/// Doc comment.
/// Supports new lines.
///
/// Testing
struct B {
    /// Doc of field
    ///
    /// Testing
    name: String,
}

#[derive(TS)]
#[ts(export_to = "tests-out/docs/")]
/// Doc comment.
/// Supports new lines.
///
/// Testing
struct C {}

#[derive(TS)]
#[ts(export_to = "tests-out/docs/")]
/// Doc comment.
/// Supports new lines.
///
/// Testing
struct D;

#[derive(TS)]
#[ts(export_to = "tests-out/docs/")]
/// Doc comment.
/// Supports new lines.
///
/// Testing
enum E {}

#[derive(TS)]
#[ts(export_to = "tests-out/docs/")]
/// Doc comment.
/// Supports new lines.
///
/// Testing
enum F {
    /// Doc of variant
    ///
    /// Testing
    VarA,
    /// Doc of variant
    ///
    /// Testing
    VarB(),
    /// Doc of variant
    ///
    /// Testing
    VarC {
        /// Doc of field of variant
        ///
        /// Testing
        variant_field: i32,
    },
}

#[derive(TS)]
#[ts(export_to = "tests-out/docs/")]
struct G {
    /// Docs
    some_other_field: i32,

    /// Some documentation that should probably NOT be exported
    #[ts(flatten)]
    f: F,
}

/* ============================================================================================== */

#[test]
fn export_a() {
    A::export().unwrap();

    let expected_content = if cfg!(feature = "format") {
        concat!(
            "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\n",
            "/**\n",
            " * Doc comment.\n",
            " * Supports new lines.\n",
            " *\n",
            " * Testing\n",
            " */\n",
            "export type A = {\n",
            "  /**\n",
            "   * Doc of field\n",
            "   *\n",
            "   * Testing\n",
            "   */\n",
            "  name: string;\n",
            "};\n",
        )
    } else {
        concat!(
            "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\n",
            "/**\n",
            " * Doc comment.\n",
            " * Supports new lines.\n",
            " *\n",
            " * Testing\n",
            " */\n",
            "export type A = { \n",
            "/**\n",
            " * Doc of field\n",
            " *\n",
            " * Testing\n",
            " */\n",
            "name: string, }"
        )
    };

    let actual_content = fs::read_to_string("tests-out/docs/A.ts").unwrap();

    assert_eq!(actual_content, expected_content);
}

#[test]
fn export_b() {
    B::export().unwrap();

    let expected_content = if cfg!(feature = "format") {
        concat!(
            "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\n",
            "/**\n",
            " * Doc comment.\n",
            " * Supports new lines.\n",
            " *\n",
            " * Testing\n",
            " */\n",
            "export type B = {\n",
            "  /**\n",
            "   * Doc of field\n",
            "   *\n",
            "   * Testing\n",
            "   */\n",
            "  name: string;\n",
            "};\n",
        )
    } else {
        concat!(
            "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\n",
            "/**\n",
            " * Doc comment.\n",
            " * Supports new lines.\n",
            " *\n",
            " * Testing\n",
            " */\n",
            "export type B = { \n",
            "/**\n",
            " * Doc of field\n",
            " *\n",
            " * Testing\n",
            " */\n",
            "name: string, }",
        )
    };

    let actual_content = fs::read_to_string("tests-out/docs/B.ts").unwrap();

    assert_eq!(actual_content, expected_content);
}

#[test]
fn export_c() {
    C::export().unwrap();

    let expected_content = if cfg!(feature = "format") {
        concat!(
            "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\n",
            "/**\n",
            " * Doc comment.\n",
            " * Supports new lines.\n",
            " *\n",
            " * Testing\n",
            " */\n",
            "export type C = Record<string, never>;\n"
        )
    } else {
        concat!(
            "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\n",
            "/**\n",
            " * Doc comment.\n",
            " * Supports new lines.\n",
            " *\n",
            " * Testing\n",
            " */\n",
            "export type C = Record<string, never>;"
        )
    };

    let actual_content = fs::read_to_string("tests-out/docs/C.ts").unwrap();

    assert_eq!(actual_content, expected_content);
}

#[test]
fn export_d() {
    D::export().unwrap();

    let expected_content = if cfg!(feature = "format") {
        concat!(
            "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\n",
            "/**\n",
            " * Doc comment.\n",
            " * Supports new lines.\n",
            " *\n",
            " * Testing\n",
            " */\n",
            "export type D = null;\n"
        )
    } else {
        concat!(
            "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\n",
            "/**\n",
            " * Doc comment.\n",
            " * Supports new lines.\n",
            " *\n",
            " * Testing\n",
            " */\n",
            "export type D = null;"
        )
    };
    let actual_content = fs::read_to_string("tests-out/docs/D.ts").unwrap();

    assert_eq!(actual_content, expected_content);
}

#[test]
fn export_e() {
    E::export().unwrap();

    let expected_content = if cfg!(feature = "format") {
        concat!(
            "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\n",
            "/**\n",
            " * Doc comment.\n",
            " * Supports new lines.\n",
            " *\n",
            " * Testing\n",
            " */\n",
            "export type E = never;\n"
        )
    } else {
        concat!(
            "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\n",
            "/**\n",
            " * Doc comment.\n",
            " * Supports new lines.\n",
            " *\n",
            " * Testing\n",
            " */\n",
            "export type E = never;"
        )
    };

    let actual_content = fs::read_to_string("tests-out/docs/E.ts").unwrap();

    assert_eq!(actual_content, expected_content);
}

#[test]
fn export_f() {
    F::export().unwrap();

    let expected_content = if cfg!(feature = "format") {
        concat!(
            "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\n",
            "/**\n",
            " * Doc comment.\n",
            " * Supports new lines.\n",
            " *\n",
            " * Testing\n",
            " */\n",
            "export type F = \"VarA\" | { \"VarB\": never[] } | {\n",
            "  \"VarC\": {\n",
            "    /**\n",
            "     * Doc of field of variant\n",
            "     *\n",
            "     * Testing\n",
            "     */\n",
            "    variant_field: number;\n",
            "  };\n",
            "};\n"
        )
    } else {
        concat!(
            "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\n",
            "/**\n",
            " * Doc comment.\n",
            " * Supports new lines.\n",
            " *\n",
            " * Testing\n",
            " */\n",
            "export type F = \"VarA\" | { \"VarB\": never[] } | { \"VarC\": { \n",
            "/**\n",
            " * Doc of field of variant\n",
            " *\n",
            " * Testing\n",
            " */\n",
            "variant_field: number, } };"
        )
    };

    let actual_content = fs::read_to_string("tests-out/docs/F.ts").unwrap();

    assert_eq!(actual_content, expected_content);
}

#[test]
fn export_g() {
    G::export().unwrap();

    let expected_content = if cfg!(feature = "format") {
        concat!(
            "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\n",
            "export type G =\n",
            "  & {\n",
            "    /**\n",
            "     * Docs\n",
            "     */\n",
            "    some_other_field: number;\n",
            "  }\n",
            "  & (\"VarA\" | { \"VarB\": never[] } | {\n",
            "    \"VarC\": {\n",
            "      /**\n",
            "       * Doc of field of variant\n",
            "       *\n",
            "       * Testing\n",
            "       */\n",
            "      variant_field: number;\n",
            "    };\n",
            "  });\n"
        )
    } else {
        concat!(
            "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n",
            "\n",
            "export type G = { \n",
            "/**\n",
            " * Docs\n",
            " */\n",
            "some_other_field: number, } & (\"VarA\" | { \"VarB\": never[] } | { \"VarC\": { \n",
            "/**\n",
            " * Doc of field of variant\n",
            " *\n",
            " * Testing\n",
            " */\n",
            "variant_field: number, } })",
        )



    };

    let actual_content = fs::read_to_string("tests-out/docs/G.ts").unwrap();

    assert_eq!(actual_content, expected_content);
}
