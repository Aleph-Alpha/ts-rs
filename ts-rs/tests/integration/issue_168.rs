#![allow(unused)]

use std::collections::HashMap;

use ts_rs::TS;

#[derive(TS)]
#[ts(export, export_to = "issue_168/")]
pub struct Foo {
    map: HashMap<usize, Bar>,
}

#[derive(TS)]
#[ts(export, export_to = "issue_168/")]
pub struct FooInlined {
    #[ts(inline)]
    map: HashMap<usize, Bar>,
}

#[derive(TS)]
#[ts(export, export_to = "issue_168/")]
struct Bar {
    #[ts(inline)]
    map: HashMap<usize, Baz>,
}

#[derive(TS)]
#[ts(export, export_to = "issue_168/")]
struct Baz {
    #[ts(inline)]
    map: HashMap<usize, String>,
}

#[test]
fn issue_168() {
    let extension = if cfg!(feature = "import-esm") {
        ".js".to_string()
    } else {
        std::env::var("TS_RS_IMPORT_EXTENSION")
            .map(|x| format!(".{x}"))
            .unwrap_or("".into())
    };

    assert_eq!(
        FooInlined::export_to_string().unwrap(),
        "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\
         \n\
         export type FooInlined = { map: { [key: number]: { map: { [key: number]: { map: { [key: number]: string }, } }, } }, };\n"
    );
    assert_eq!(
        Foo::export_to_string().unwrap(),
        format!("// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\
         import type {{ Bar }} from \"./Bar{extension}\";\n\
         \n\
         export type Foo = {{ map: {{ [key: number]: Bar }}, }};\n")
    );
}
