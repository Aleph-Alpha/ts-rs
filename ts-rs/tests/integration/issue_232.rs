#![allow(unused)]

use ts_rs::{Config, TS};

#[derive(TS)]
#[ts(export, export_to = "issue_232/")]
struct State {
    a: Result<EnumWithName, String>,
    b: Result<EnumWithName, String>,
}

#[derive(TS)]
#[ts(export, export_to = "issue_232/")]
struct StateInlined {
    #[ts(inline)]
    a: Result<EnumWithName, String>,
    #[ts(inline)]
    b: Result<EnumWithName, String>,
}

#[derive(TS)]
#[ts(export, export_to = "issue_232/")]
struct StateInlinedVec {
    #[ts(inline)]
    a: Vec<Result<EnumWithName, String>>,
    #[ts(inline)]
    b: Vec<Result<EnumWithName, String>>,
}

#[derive(TS)]
#[ts(export, export_to = "issue_232/")]
struct EnumWithName {
    name: String,
    inner: Enum,
}

#[derive(TS)]
#[ts(export, export_to = "issue_232/")]
enum Enum {
    A,
    B,
}

#[test]
fn issue_232() {
    let cfg = Config::from_env();
    let extension = match cfg.import_extension() {
        "" => String::new(),
        ext => format!(".{ext}"),
    };

    println!("{}", StateInlinedVec::export_to_string(&cfg).unwrap());
    assert_eq!(
        StateInlined::export_to_string(&cfg).unwrap(),
        format!("// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\
        import type {{ Enum }} from \"./Enum{extension}\";\n\
        \n\
        export type StateInlined = {{ \
            a: {{ Ok : {{ name: string, inner: Enum, }} }} | {{ Err : string }}, \
            b: {{ Ok : {{ name: string, inner: Enum, }} }} | {{ Err : string }}, \
        }};\n")
    );
    assert_eq!(
        State::export_to_string(&cfg).unwrap(),
        format!("// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\
        import type {{ EnumWithName }} from \"./EnumWithName{extension}\";\n\
        \n\
        export type State = {{ \
            a: {{ Ok : EnumWithName }} | {{ Err : string }}, \
            b: {{ Ok : EnumWithName }} | {{ Err : string }}, \
        }};\n")
    );
}
