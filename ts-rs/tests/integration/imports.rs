#![allow(dead_code)]

use ts_rs::TS;

#[derive(TS)]
#[ts(export_to = "imports/ts_rs_test_type_a.ts")]
pub struct TestTypeA<T> {
    value: T,
}

#[derive(TS)]
#[ts(export_to = "imports/ts_rs_test_type_b.ts")]
pub struct TestTypeB<T> {
    value: T,
}

#[derive(TS)]
#[ts(export_to = "imports/")]
pub enum TestEnum {
    C { value: TestTypeB<i8> },
    A1 { value: TestTypeA<i32> },
    A2 { value: TestTypeA<i8> },
}

#[test]
fn test_def() {
    // The only way to get access to how the imports look is to export the type and load the exported file
    TestEnum::export_all().unwrap();
    let text = std::fs::read_to_string(TestEnum::default_output_path().unwrap()).unwrap();
    let extension = std::env::var("TS_RS_IMPORT_EXTENSION")
        .map(|x| format!(".{x}"))
        .unwrap_or("".into());
    let mut expected = String::with_capacity(512);

    expected.push_str("// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n");
    expected.push_str(&format!(
        "import type {{ TestTypeA }} from \"./ts_rs_test_type_a{extension}\";\n"
    ));
    expected.push_str(&format!(
        "import type {{ TestTypeB }} from \"./ts_rs_test_type_b{extension}\";\n"
    ));
    expected.push('\n');

    if (cfg!(feature = "format")) {
        expected.push_str(concat!(
            "export type TestEnum = { \"C\": { value: TestTypeB<number> } } | {\n",
            "  \"A1\": { value: TestTypeA<number> };\n",
            "} | { \"A2\": { value: TestTypeA<number> } };\n",
        ))
    } else {
        expected.push_str(concat!(
            "export type TestEnum = { \"C\": { value: TestTypeB<number>, } } | { \"A1\": { value: TestTypeA<number>, } } | { \"A2\": { value: TestTypeA<number>, } };",
            "\n",
        ))
    };

    assert_eq!(text, expected);
}
