use std::{
    collections::{HashMap, HashSet},
    fs,
    io::Write,
    path::{Path, PathBuf},
    process::Stdio,
};

use clap::Parser;
use color_eyre::{owo_colors::OwoColorize, Result};

mod path;

#[derive(Parser, Debug)]
struct Args {
    /// Defines where your TS bindings will be saved by setting TS_RS_EXPORT_DIR
    #[arg(long, short, default_value = "./bindings")]
    output_directory: PathBuf,

    /// Disables warnings caused by using serde attributes that ts-rs cannot process
    #[arg(long)]
    no_warnings: bool,

    /// Adds the ".js" extension to import paths
    #[arg(long)]
    esm_imports: bool,

    /// Formats the generated TypeScript files
    #[arg(long)]
    format: bool,

    /// Generates an index.ts file in your --output-directory that re-exports all
    /// types generated by ts-rs
    #[arg(long = "index")]
    generate_index_ts: bool,

    /// Do not capture `cargo test`'s output, and pass --nocapture to the test binary
    #[arg(long)]
    no_capture: bool,
}

macro_rules! feature {
    ($cargo_invocation: expr, $args: expr, { $($field: ident => $feature: literal),* $(,)? }) => {
        $(
            if $args.$field {
                $cargo_invocation
                    .arg("--features")
                    .arg(format!("ts-rs/{}", $feature));
            }
        )*
    };
}

fn main() -> Result<()> {
    color_eyre::install()?;

    let args = Args::parse();

    let mut cargo_invocation = std::process::Command::new("cargo");

    let metadata_path = args.output_directory.join("ts_rs.meta");
    if metadata_path.exists() {
        fs::remove_file(&metadata_path)?;
    }

    cargo_invocation
        .arg("test")
        .arg("export_bindings_")
        .arg("--features")
        .arg("ts-rs/export")
        .stdout(if args.no_capture {
            Stdio::inherit()
        } else {
            Stdio::piped()
        })
        .stderr(if args.no_capture {
            Stdio::inherit()
        } else {
            Stdio::piped()
        })
        .env("TS_RS_EXPORT_DIR", path::absolute(&args.output_directory)?);

    feature!(cargo_invocation, args, {
        no_warnings => "no-serde-warnings",
        esm_imports => "import-esm",
        format => "format",
    });

    if args.no_capture {
        cargo_invocation.arg("--").arg("--nocapture");
    }

    cargo_invocation.spawn()?.wait()?;

    if args.generate_index_ts {
        let metadata = fs::read_to_string(&metadata_path)?
            .lines()
            .map(ToOwned::to_owned)
            .collect::<HashSet<_>>()
            .into_iter()
            .fold(HashMap::<_, Vec<_>>::default(), |mut acc, cur| {
                let columns = cur.splitn(3, ',').collect::<Vec<_>>();

                let type_ts_name = columns[0].to_owned();
                let type_rs_name = columns[1].to_owned();
                let path = Path::new(columns[2]).to_owned();
                acc.entry(type_ts_name)
                    .and_modify(|v| v.push((type_rs_name.clone(), path.clone())))
                    .or_insert(vec![(type_rs_name, path)]);

                acc
            });

        let index_path = args.output_directory.join("index.ts");

        if index_path.exists() {
            fs::remove_file(&index_path)?;
        }

        if !metadata.is_empty() {
            metadata
                .iter()
                .filter(|x| x.1.len() > 1)
                .for_each(|(ty, paths)| {
                    eprintln!(
                        "{} Multiple types being exported with the name \"{}\"",
                        "Warning:".yellow().bold(),
                        ty.green().bold()
                    );

                    for (ty_rs, path) in paths {
                        eprintln!(
                            "  {} {} {}",
                            "-".blue().bold(),
                            "Type:".bold(),
                            ty_rs.cyan(),
                        );
                        eprintln!("    {} {}", "Path:".bold(), path.to_string_lossy());
                        eprintln!();
                    }

                    eprintln!();
                });

            let mut index = fs::OpenOptions::new()
                .create(true)
                .append(true)
                .open(index_path)?;

            index.write_all(
                b"// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\n"
            )?;

            for file in metadata.iter().map(|x| &x.1[0]) {
                index.write_fmt(format_args!("export * from {file:?};\n"))?;
            }
        }
    }

    fs::remove_file(&metadata_path)?;

    Ok(())
}
