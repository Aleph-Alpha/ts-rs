#![warn(clippy::pedantic, clippy::nursery)]

use std::{
    collections::{HashMap, HashSet},
    fs,
    io::Write,
};

use clap::Parser;
use color_eyre::{owo_colors::OwoColorize, Result};

mod args;
mod cargo;
mod metadata;
mod path;

use args::Args;
use metadata::{name_collision_warning, Metadata};

const NOTE: &[u8; 109] = b"// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n";

fn main() -> Result<()> {
    color_eyre::install()?;

    let args = Args::parse();

    let metadata_path = args.output_directory.join("ts_rs.meta");
    if metadata_path.exists() {
        fs::remove_file(&metadata_path)?;
    }

    cargo::invoke(&args)?;

    if args.generate_index_ts {
        let metadata_content = fs::read_to_string(&metadata_path)?;
        let metadata = metadata_content
            .lines()
            .collect::<HashSet<_>>()
            .into_iter()
            .fold(HashMap::<_, Vec<_>>::default(), |mut acc, cur| {
                let (key, value) = cur.split_once(',').unwrap();

                let value = Metadata::try_from(value).unwrap();
                acc.entry(key).or_default().push(value);

                acc
            });

        let index_path = args.output_directory.join("index.ts");

        if index_path.exists() {
            fs::remove_file(&index_path)?;
        }

        if !metadata.is_empty() {
            let mut naming_collisions = metadata.iter().filter(|x| x.1.len() > 1).peekable();

            let has_collisions = naming_collisions.peek().is_some();

            naming_collisions.for_each(|(&ty, meta)| name_collision_warning(ty, meta));

            if has_collisions {
                eprintln!(
                    "{} due to the naming collisions listed above, generating an index.ts file is not possible",
                    "Error:".red().bold()
                );
            } else {
                let mut index = fs::OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(index_path)?;

                index.write_all(NOTE)?;

                for file in metadata.iter().flat_map(|x| x.1).map(|x| x.export_path) {
                    index.write_fmt(format_args!("\nexport * from {file:?};"))?;
                }
            }
        }
    }

    fs::remove_file(&metadata_path)?;

    Ok(())
}
