use std::{
    collections::{HashMap, HashSet},
    fs,
    io::Write,
    path::{Path, PathBuf},
};

use clap::Parser;
use color_eyre::{owo_colors::OwoColorize, Result};

mod path;

#[derive(Parser, Debug)]
struct Args {
    /// Defines where your TS bindings will be saved by setting TS_RS_EXPORT_DIR
    #[arg(long, short, default_value = "./bindings")]
    output_directory: PathBuf,

    /// Disables warnings caused by using serde attributes that ts-rs cannot process
    #[arg(long)]
    no_warnings: bool,

    /// Adds the ".js" extension to import paths
    #[arg(long)]
    esm_imports: bool,

    /// Formats the generated TypeScript files
    #[arg(long)]
    format: bool,

    #[arg(long = "index")]
    generate_index_ts: bool,
}

macro_rules! feature {
    ($cargo_invocation: expr, $args: expr, { $($field: ident => $feature: literal),* $(,)? }) => {
        $(
            if $args.$field {
                $cargo_invocation
                    .arg("--features")
                    .arg(format!("ts-rs/{}", $feature));
            }
        )*
    };
}

fn main() -> Result<()> {
    color_eyre::install()?;

    let args = Args::parse();

    let mut cargo_invocation = std::process::Command::new("cargo");

    let metadata_path = args.output_directory.join("ts_rs.meta");
    if metadata_path.exists() {
        fs::remove_file(&metadata_path)?;
    }

    cargo_invocation
        .arg("test")
        .arg("export_bindings_")
        .arg("--features")
        .arg("ts-rs/export")
        .env("TS_RS_EXPORT_DIR", path::absolute(&args.output_directory)?);

    feature!(cargo_invocation, args, {
        no_warnings => "no-serde-warnings",
        esm_imports => "import-esm",
        format => "format",
    });

    cargo_invocation.spawn()?.wait()?;

    if args.generate_index_ts {
        let metadata = fs::read_to_string(&metadata_path)?
            .lines()
            .map(ToOwned::to_owned)
            .collect::<HashSet<_>>()
            .into_iter()
            .fold(HashMap::<_, Vec<_>>::default(), |mut acc, cur| {
                let (type_name, path) = cur.split_once(',').unwrap();

                let type_name = type_name.to_owned();
                let path = Path::new(path).to_owned();
                acc.entry(type_name)
                    .and_modify(|v| v.push(path.clone()))
                    .or_insert(vec![path]);

                acc
            });

        let index_path = args.output_directory.join("index.ts");

        if index_path.exists() {
            fs::remove_file(&index_path)?;
        }

        if !metadata.is_empty() {
            metadata
                .iter()
                .filter(|x| x.1.len() > 1)
                .for_each(|(ty, paths)| {
                    eprintln!(
                        "{} Multiple types named \"{}\" exported to different paths:",
                        "Warning:".yellow().bold(),
                        ty.green()
                    );

                    for path in paths {
                        eprintln!("  {} {}", "-".blue().bold(), path.to_string_lossy().bold());
                    }

                    eprintln!();
                });

            let mut index = fs::OpenOptions::new()
                .create(true)
                .append(true)
                .open(index_path)?;

            index.write_all(
                b"// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.\n\n"
            )?;

            for file in metadata.iter().map(|x| &x.1[0]) {
                index.write_fmt(format_args!("export * from {file:?};\n"))?;
            }
        }
    }

    fs::remove_file(&metadata_path)?;

    Ok(())
}
