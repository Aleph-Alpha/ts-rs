use std::{
    collections::HashMap,
    path::{Path, PathBuf},
};

use clap::Parser;
use color_eyre::{eyre::bail, owo_colors::OwoColorize, Result};
use serde::Deserialize;

#[derive(Parser, Debug)]
#[allow(clippy::struct_excessive_bools)]
pub struct Args {
    #[clap(skip)]
    pub overrides: HashMap<String, String>,

    /// Path to the `ts-rs` config file
    #[arg(long)]
    pub config: Option<PathBuf>,

    /// Defines where your TS bindings will be saved by setting `TS_RS_EXPORT_DIR`
    #[arg(long, short)]
    pub output_directory: Option<PathBuf>,

    /// Disables warnings caused by using serde attributes that ts-rs cannot process
    #[arg(long)]
    pub no_warnings: bool,

    /// Adds the ".js" extension to import paths
    #[arg(long)]
    pub esm_imports: bool,

    /// Formats the generated TypeScript files
    #[arg(long)]
    pub format: bool,

    /// Generates an index.ts file in your --output-directory that re-exports all
    /// types generated by ts-rs
    #[arg(long = "index")]
    pub generate_index_ts: bool,

    /// Generates only a single index.ts file in your --output-directory that
    /// contains all exported types
    #[arg(long = "merge")]
    pub merge_files: bool,

    /// Do not capture `cargo test`'s output, and pass --nocapture to the test binary
    #[arg(long = "nocapture")]
    pub no_capture: bool,
}

// keeping this separate from `Args` for now :shrug:
#[derive(Default, Deserialize)]
#[serde(deny_unknown_fields, default, rename_all = "kebab-case")]
#[allow(clippy::struct_excessive_bools)]
pub struct Config {
    /// Type overrides for types implemented inside ts-rs.
    pub overrides: HashMap<String, String>,
    pub output_directory: Option<PathBuf>,
    pub no_warnings: bool,
    pub esm_imports: bool,
    pub format: bool,

    #[serde(rename = "index")]
    pub generate_index_ts: bool,

    #[serde(rename = "merge")]
    pub merge_files: bool,

    #[serde(rename = "nocapture")]
    pub no_capture: bool,
}

impl Args {
    pub fn load() -> Result<Self> {
        let mut args = Self::parse();

        let cfg = Config::load_from_file(args.config.as_deref())?;

        args.merge(cfg);
        args.verify()?;

        Ok(args)
    }

    pub fn output_directory(&self) -> &Path {
        self.output_directory
            .as_deref()
            .expect("Output directory must not be `None`")
    }

    fn verify(&self) -> Result<()> {
        if self.merge_files && self.generate_index_ts {
            bail!(
                "{}: --index is not compatible with --merge",
                "Error".bold().red()
            );
        }

        if self.output_directory.is_none() {
            bail!("{}: You must provide the output diretory, either through the config file or the --output-directory flag", "Error".bold().red())
        }

        Ok(())
    }

    fn merge(
        &mut self,
        Config {
            overrides,
            output_directory,
            no_warnings,
            esm_imports,
            format,
            generate_index_ts,
            merge_files,
            no_capture,
        }: Config,
    ) {
        // QUESTION: This gives the CLI flag priority over the config file's value,
        // is this the correct order?
        self.output_directory = output_directory.or_else(|| self.output_directory.clone());

        self.overrides = overrides;
        self.no_warnings |= no_warnings;
        self.esm_imports |= esm_imports;
        self.format |= format;
        self.generate_index_ts |= generate_index_ts;
        self.merge_files |= merge_files;
        self.no_capture |= no_capture;
    }
}

impl Config {
    fn load_from_file(path: Option<&Path>) -> Result<Self> {
        if let Some(path) = path {
            if !path.is_file() {
                bail!("The provided path doesn't exist");
            }

            let content = std::fs::read_to_string(path)?;
            return Ok(toml::from_str(&content)?);
        }

        // TODO: from where do we actually load the config?
        let path = Path::new("./ts-rs.toml");
        if !path.is_file() {
            return Ok(Self::default());
        }

        let content = std::fs::read_to_string(path)?;
        Ok(toml::from_str(&content)?)
    }
}
