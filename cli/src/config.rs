use clap::Parser;
use color_eyre::eyre::bail;
use color_eyre::Result;
use serde::Deserialize;
use std::collections::HashMap;
use std::path::{Path, PathBuf};

#[derive(Parser, Debug)]
#[allow(clippy::struct_excessive_bools)]
pub struct Args {
    /// Defines where your TS bindings will be saved by setting `TS_RS_EXPORT_DIR`
    #[arg(long, short)]
    pub output_directory: PathBuf,

    /// Disables warnings caused by using serde attributes that ts-rs cannot process
    #[arg(long)]
    pub no_warnings: bool,

    /// Adds the ".js" extension to import paths
    #[arg(long)]
    pub esm_imports: bool,

    /// Formats the generated TypeScript files
    #[arg(long)]
    pub format: bool,

    /// Generates an index.ts file in your --output-directory that re-exports all
    /// types generated by ts-rs
    #[arg(long = "index")]
    pub generate_index_ts: bool,

    /// Generates only a single index.ts file in your --output-directory that
    /// contains all exported types
    #[arg(long = "merge")]
    pub merge_files: bool,

    /// Do not capture `cargo test`'s output, and pass --nocapture to the test binary
    #[arg(long = "nocapture")]
    pub no_capture: bool,
}

// keeping this separate from `Args` for now :shrug:
#[derive(Default, Deserialize)]
#[serde(deny_unknown_fields, default)]
#[allow(clippy::struct_excessive_bools)]
pub struct Config {
    // type overrides for types implemented inside ts-rs.
    pub overrides: HashMap<String, String>,
    pub output_directory: PathBuf,
    pub no_warnings: bool,
    pub esm_imports: bool,
    pub format: bool,
    pub generate_index_ts: bool,
    pub merge_files: bool,
    pub no_capture: bool,
}

impl Config {
    pub fn load() -> Result<Self> {
        let mut cfg = Self::load_from_file()?;
        cfg.merge(Args::parse());
        cfg.verify()?;
        Ok(cfg)
    }

    fn load_from_file() -> Result<Self> {
        // TODO: from where do we actually load the config?
        let path = Path::new("./ts-rs.toml");
        if !path.is_file() {
            return Ok(Self::default());
        }
        let content = std::fs::read_to_string(path)?;
        Ok(toml::from_str::<Self>(&content)?)
    }

    fn verify(&self) -> Result<()> {
        if self.merge_files && self.generate_index_ts {
            bail!("--index is not compatible with --merge");
        }
        Ok(())
    }

    fn merge(
        &mut self,
        Args {
            output_directory,
            no_warnings,
            esm_imports,
            format,
            generate_index_ts,
            merge_files,
            no_capture,
        }: Args,
    ) {
        self.output_directory = output_directory;
        self.no_warnings = no_warnings;
        self.esm_imports = esm_imports;
        self.format = format;
        self.generate_index_ts = generate_index_ts;
        self.merge_files = merge_files;
        self.no_capture = no_capture;
    }
}
